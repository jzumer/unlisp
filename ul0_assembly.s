.global footer
.global header
.global footer_ptr
.global header_ptr
.global program
.global data
.global ip
.global prev_ip
.global dp
.global prev_dp

.global reloc
.global reloc_ptr

.global symbol_tbl
.global n_symbols
.global pending_fn

.global define_str
.global define_str_lgt
.global print_str
.global print_str_lgt
.global lambda_str
.global lambda_str_lgt
.global nop_str
.global nop_str_lgt
.global if_str
.global if_str_lgt

.data

define_str: .ascii "def"
define_str_lgt: .quad . - define_str
lambda_str: .ascii "fn"
lambda_str_lgt: .quad . - lambda_str
nop_str: .ascii "nop"
nop_str_lgt: .quad . - nop_str
if_str: .ascii "if"
if_str_lgt: .quad . - if_str

print_str: .ascii "print"
print_str_lgt: .quad . - print_str
dec_str: .ascii "dec"
dec_str_lgt: .quad . - dec_str
inc_str: .ascii "inc"
inc_str_lgt: .quad . - inc_str
not_str: .ascii "not"
not_str_lgt: .quad . - not_str
less_str: .ascii "<"
less_str_lgt: .quad . - less_str
greater_str: .ascii ">"
greater_str_lgt: .quad . - greater_str
mod_str: .ascii "%"
mod_str_lgt: .quad . - mod_str

n_symbols: .quad 7

symbol_tbl:
.quad print_str, print_str_lgt - print_str, print_code_data - data
.quad dec_str, dec_str_lgt - dec_str, dec_code_data - data
.quad inc_str, inc_str_lgt - inc_str, inc_code_data - data
.quad not_str, not_str_lgt - not_str, not_code_data - data
.quad less_str, less_str_lgt - less_str, less_code_data - data
.quad greater_str, greater_str_lgt - greater_str, greater_code_data - data
.quad mod_str, mod_str_lgt - mod_str, mod_code_data - data
.space 2400, 0 # space for 100 symbols

prev_ip: .quad 0 # instruction pointer starting at previous insertion point
ip: .quad last_code_rel - program # instruction pointer at the end of previous insertion

program:
.byte 0xe9 # "entry point": jmp to start of program, i.e. past the predefined functions
.long 374 #XXX Careful, this must point to 1 past the last code. Can't be calculated...
print_code_rel: # 'what' in %rax with format (quad)size, actual_str. For sys_write, 'what' is in %rsi and 'how much' in %rdx.
# 56
.byte 0x51, 0x52, 0x56, 0x57 # push %rcx, push %rdx, push %rdi, push %rsi
.byte 0x48, 0x8b, 0x10 # mov (%rax), %rdx
.byte 0x48, 0x8d, 0x70, 0x08 # lea 8(%rax), %rsi
.byte 0x48, 0x31, 0xc0 # xor %rax, %rax
.byte 0x48, 0xff, 0xc0 # inc %rax -> sys_write
.byte 0x48, 0x31, 0xff # xor %rdi, %rdi
.byte 0x48, 0xff, 0xc7 # inc %rdi -> stdout
.byte 0x0f, 0x05 # syscall
.byte 0x48, 0x0f, 0xbe, 0x0c, 0x25, 0x00, 0x00, 0x00, 0x00 # movsx 0x0, %rcx
.byte 0x48, 0x8b, 0x14, 0x25, 0x01, 0x00, 0x00, 0x00 # mov 0x1, %rdx
.byte 0x4c, 0x8d, 0x24, 0xca # lea (%rdx, %rcx, 8), %r12
.byte 0x49, 0xc7, 0x04, 0x24, 0x00, 0x00, 0x00, 0x00 # mov $0, (%r12)
.byte 0xfe, 0x04, 0x25, 0x00, 0x00, 0x00, 0x00 # incb 0x0
.byte 0x5f, 0x5e, 0x5a, 0x59 # pop %rsi, pop %rdi, pop %rdx, pop %rcx
.byte 0xc3 # ret
dec_code_rel: # 37
.byte 0x51, 0x52
.byte 0x48, 0x8b, 0x00 # mov (%rax), %rax
.byte 0x48, 0xff, 0xc8 # dec %rax
.byte 0x48, 0x0f, 0xbe, 0x0c, 0x25, 0x00, 0x00, 0x00, 0x00 # movsx 0x0, %rcx
.byte 0x48, 0x8b, 0x14, 0x25, 0x01, 0x00, 0x00, 0x00 # mov 0x1, %rdx
.byte 0x4c, 0x8d, 0x24, 0xca # lea (%rdx, %rcx, 8), %r12
.byte 0x49, 0x89, 0x04, 0x24 # mov %rax, (%r12)
.byte 0xfe, 0x04, 0x25, 0x00, 0x00, 0x00, 0x00 # incb 0x0
.byte 0x5a, 0x59
.byte 0xc3 # ret
inc_code_rel: # 37
.byte 0x51, 0x52
.byte 0x48, 0x8b, 0x00 # mov (%rax), %rax
.byte 0x48, 0xff, 0xc0 # inc %rax
.byte 0x48, 0x0f, 0xbe, 0x0c, 0x25, 0x00, 0x00, 0x00, 0x00 # movsx 0x0, %rcx
.byte 0x48, 0x8b, 0x14, 0x25, 0x01, 0x00, 0x00, 0x00 # mov 0x1, %rdx
.byte 0x4c, 0x8d, 0x24, 0xca # lea (%rdx, %rcx, 8), %r12
.byte 0x49, 0x89, 0x04, 0x24 # mov %rax, (%r12)
.byte 0xfe, 0x04, 0x25, 0x00, 0x00, 0x00, 0x00 # incb 0x0
.byte 0x5a, 0x59
.byte 0xc3 # ret
not_code_rel: # 37
.byte 0x51, 0x52
.byte 0x48, 0x8b, 0x00 # mov (%rax), %rax
.byte 0x48, 0xf7, 0xd0 # not %rax
.byte 0x48, 0x0f, 0xbe, 0x0c, 0x25, 0x00, 0x00, 0x00, 0x00 # movsx 0x0, %rcx
.byte 0x48, 0x8b, 0x14, 0x25, 0x01, 0x00, 0x00, 0x00 # mov 0x1, %rdx
.byte 0x4c, 0x8d, 0x24, 0xca # lea (%rdx, %rcx, 8), %r12
.byte 0x49, 0x89, 0x04, 0x24 # mov %rax, (%r12)
.byte 0xfe, 0x04, 0x25, 0x00, 0x00, 0x00, 0x00 # incb 0x0
.byte 0x5a, 0x59
.byte 0xc3 # ret
less_code_rel: # 54
.byte 0x52, 0x53
.byte 0x48, 0x8b, 0x00 # mov (%rax), %rax
.byte 0x48, 0x8b, 0x09 # mov (%rcx), %rcx
.byte 0x48, 0x39, 0xc8 # cmp %rcx, %rax
.byte 0x48, 0x31, 0xc0 # xor %rax, %rax
.byte 0x48, 0xc7, 0xc1, 0x01, 0x00, 0x00, 0x00 # mov $1, %rcx
.byte 0x48, 0x0f, 0x4c, 0xc1 # cmovl %rcx, %rax
.byte 0x48, 0x0f, 0xbe, 0x14, 0x25, 0x00, 0x00, 0x00, 0x00 # movsx 0x0, %rdx
.byte 0x48, 0x8b, 0x1c, 0x25, 0x01, 0x00, 0x00, 0x00 # mov 0x1, %rbx
.byte 0x4c, 0x8d, 0x24, 0xd3 # lea (%rbx, %rdx, 8), %r12
.byte 0x49, 0x89, 0x04, 0x24 # mov %rax, (%r12)
.byte 0xfe, 0x04, 0x25, 0x00, 0x00, 0x00, 0x00 # incb 0x0
.byte 0x5b, 0x5a
.byte 0xc3 # ret
greater_code_rel: # 54
.byte 0x52, 0x53
.byte 0x48, 0x8b, 0x00 # mov (%rax), %rax
.byte 0x48, 0x8b, 0x09 # mov (%rcx), %rcx
.byte 0x48, 0x39, 0xc8 # cmp %rcx, %rax
.byte 0x48, 0x31, 0xc0 # xor %rax, %rax
.byte 0x48, 0xc7, 0xc1, 0x01, 0x00, 0x00, 0x00 # mov $1, %rcx
.byte 0x48, 0x0f, 0x4f, 0xc1 # cmovg %rcx, %rax
.byte 0x48, 0x0f, 0xbe, 0x14, 0x25, 0x00, 0x00, 0x00, 0x00 # movsx 0x0, %rdx
.byte 0x48, 0x8b, 0x1c, 0x25, 0x01, 0x00, 0x00, 0x00 # mov 0x1, %rbx
.byte 0x4c, 0x8d, 0x24, 0xd3 # lea (%rbx, %rdx, 8), %r12
.byte 0x49, 0x89, 0x04, 0x24 # mov %rax, (%r12)
.byte 0xfe, 0x04, 0x25, 0x00, 0x00, 0x00, 0x00 # incb 0x0
.byte 0x5b, 0x5a
.byte 0xc3 # ret
mod_code_rel: # 44
.byte 0x50, 0x51, 0x52, 0x53 # push %rax, %rcx, %rdx, %rbx
.byte 0x48, 0x8b, 0x00 # mov (%rax), %rax
.byte 0x48, 0x8b, 0x09 # mov (%rcx), %rcx
.byte 0x48, 0x89, 0xcb # mov %rcx, %rbx
.byte 0x48, 0x31, 0xc9 # xor %rcx, %rcx
.byte 0x48, 0xf7, 0xf3 # div %rbx
.byte 0x48, 0x89, 0xd1 # mov %rdx, %rcx
.byte 0x48, 0x0f, 0xbe, 0x14, 0x25, 0x00, 0x00, 0x00, 0x00 # movsx 0x0, %rdx
.byte 0x48, 0x8b, 0x1c, 0x25, 0x01, 0x00, 0x00, 0x00 # mov 0x1, %rbx
.byte 0x4c, 0x8d, 0x24, 0xd3 # lea (%rbx, %rdx, 8), %r12
.byte 0x49, 0x89, 0x0c, 0x24 # mov %rcx, (%r12)
.byte 0xfe, 0x04, 0x25, 0x00, 0x00, 0x00, 0x00 # incb 0x0
.byte 0x5b, 0x5a, 0x59, 0x58 # pop %rbx, %rdx, %rcx, %rax
.byte 0xc3 # ret
last_code_rel:
.space 65536 # Enough space for a bootstrap program

header_ptr: .quad 0
footer_ptr: .quad 0

reloc_ptr: .quad 352
reloc:
.quad 0x0, print_code_rel + 30, 0x0, print_code_rel + 38, 0x0, print_code_rel + 57
.quad 0x0, dec_code_rel + 13, 0x0, dec_code_rel + 21, 0x0, dec_code_rel + 36
.quad 0x0, inc_code_rel + 13, 0x0, inc_code_rel + 21, 0x0, inc_code_rel + 36
.quad 0x0, not_code_rel + 13, 0x0, not_code_rel + 21, 0x0, not_code_rel + 36
.quad 0x0, less_code_rel + 30, 0x0, less_code_rel + 38, 0x0, less_code_rel + 53
.quad 0x0, greater_code_rel + 30, 0x0, greater_code_rel + 38, 0x0, greater_code_rel + 53
.quad 0x0, mod_code_rel + 27, 0x0, mod_code_rel + 35, 0x0, mod_code_rel + 50
.quad 0x1, data + 1 # reloc for the memory pointer offset
.space 65536 # format is (type, address) where type is 0 if 32-bit, if 64-bit, and 2 if program-relative 32-bit

pending_fn: .quad 0 # if !=0, the index in the symbol table where the lambda will
# preemptively insert itself.

prev_dp: .quad 2169 # data pointer starting at previous insertion point
dp: .quad 2169 # current data pointer

data:
.byte 0 # runtime next-memory pointer
.quad 0x71 # memory pointer offset (i.e. size of code)
print_code_data:
.quad 0x1, print_code_rel - program
dec_code_data:
.quad 0x1, dec_code_rel - program
inc_code_data:
.quad 0x1, inc_code_rel - program
not_code_data:
.quad 0x1, not_code_rel - program
less_code_data:
.quad 0x2, less_code_rel - program
greater_code_data:
.quad 0x2, greater_code_rel - program
mod_code_data:
.quad 0x2, mod_code_rel - program
.space 2048
.space 65536 # Enough space for the bootstrap data

.bss
header: .space 2048
footer: .space 2048
